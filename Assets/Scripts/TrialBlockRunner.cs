// FILE: TrialBlockRunner.cs
using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using CondLib = StimulusConditionsLibrary;

[DisallowMultipleComponent]
public class TrialBlockRunner : MonoBehaviour
{
    [Header("References")]
    public ExperimentSpec spec;
    public StimulusBuilder builder;
    public CsvLogger csvLogger;
    public StimDebugHUD hud;
    public TargetResponseController targetResponseController;

    [Header("Control")]
    public bool autoStartOnPlay = true;
    public bool loopBlock = false;

    [Header("Trial start / response")]
    public KeyCode startKey = KeyCode.Space;
    public int maxResponseFrames = 0;

    [Header("Logging")]
    public string outputFileName = "Dots.tsv";         // <-- default prefix shortened
    public bool appendDateTimeToFilename = true;       // <-- keep appending

    // ----------------- internal state -----------------
    private List<ExperimentSpec.PlannedTrial> _allPlannedTrials;
    private Queue<ExperimentSpec.PlannedTrial> _trialQueue;

    private int _startedTrialCount = 0;
    private float _accum;
    private float _simDt;

    private ExperimentSpec.PlannedTrial _currentTrial;
    private CondLib.StimulusCondition _currentCond;

    private int _frameInStimulus;
    private System.Random _rng;

    private StringBuilder _mkPayloadBuilder;
    private StringBuilder _colorPayloadBuilder;

    private enum TrialPhase { WaitingForStart, Stimulus, TargetsResponse, Done }
    private TrialPhase _phase = TrialPhase.Done;

    private int _responseFrameIndex = 0;

    void Awake()
    {
        if (spec == null || builder == null)
        {
            Debug.LogError("[TrialBlockRunner] Assign 'spec' and 'builder' in inspector.");
            enabled = false;
            return;
        }

        _simDt = spec.SimDt;
        _rng = new System.Random(1234567);
    }

    void Start()
    {
        if (targetResponseController != null)
            targetResponseController.maxResponseFrames = maxResponseFrames;

        if (autoStartOnPlay)
            BeginBlock();
    }

    public void BeginBlock()
    {
        _allPlannedTrials = spec.GetPlannedTrials(_rng);

        if (_allPlannedTrials == null || _allPlannedTrials.Count == 0)
        {
            Debug.LogError("[TrialBlockRunner] No trials generated by ExperimentSpec.");
            enabled = false;
            return;
        }

        _trialQueue = new Queue<ExperimentSpec.PlannedTrial>(_allPlannedTrials);
        _startedTrialCount = 0;

        // Precompute counts for this block run
        int targetN = spec.GetTargetNumberTrialsEstimate();
        int generatedN = _allPlannedTrials.Count;

        if (csvLogger != null)
        {
            string path = BuildSessionPathSimple();
            csvLogger.BeginSession(path, spec.translationSpeed_degPerSec, spec.viewDistance_m);

            // Set counts AFTER BeginSession so meta writes reflect them immediately
            csvLogger.SetTargetNumberTrials(targetN);
            csvLogger.SetGeneratedTrials(generatedN);
        }

        if (hud != null)
            hud.Bind(this);

        NextTrial();
    }

    private string BuildSessionPathSimple()
    {
        string baseName = string.IsNullOrWhiteSpace(outputFileName) ? "Dots.tsv" : outputFileName.Trim();

        if (!appendDateTimeToFilename)
            return baseName;

        // YYMMDD_HHMM (no seconds, 2-digit year)
        string stamp = DateTime.Now.ToString("yyMMdd_HHmm");

        int dot = baseName.LastIndexOf('.');
        if (dot > 0)
        {
            string name = baseName.Substring(0, dot);
            string ext = baseName.Substring(dot);
            return name + "_" + stamp + ext;
        }
        return baseName + "_" + stamp;
    }

    private void NextTrial()
    {
        if (_trialQueue == null || _trialQueue.Count == 0)
        {
            if (csvLogger != null)
                csvLogger.EndSession();

            if (loopBlock)
            {
                _trialQueue = new Queue<ExperimentSpec.PlannedTrial>(_allPlannedTrials);
                _startedTrialCount = 0;

                if (csvLogger != null)
                {
                    string path = BuildSessionPathSimple();
                    csvLogger.BeginSession(path, spec.translationSpeed_degPerSec, spec.viewDistance_m);

                    // Re-assert block counts for the new session file
                    csvLogger.SetTargetNumberTrials(spec.GetTargetNumberTrialsEstimate());
                    csvLogger.SetGeneratedTrials(_allPlannedTrials != null ? _allPlannedTrials.Count : 0);
                }

                NextTrial();
                return;
            }

            _phase = TrialPhase.Done;
            enabled = false;
            return;
        }

        _currentTrial = _trialQueue.Dequeue();
        _currentCond = spec.BuildEffectiveCondition(_currentTrial);

        _frameInStimulus = 0;
        _accum = 0f;
        _responseFrameIndex = 0;
        _phase = TrialPhase.WaitingForStart;
        _startedTrialCount++;

        _mkPayloadBuilder = new StringBuilder();
        _colorPayloadBuilder = new StringBuilder();

        // Builder setup
        builder.viewDistanceMeters = spec.viewDistance_m;
        builder.apertureDeg = spec.apertureRadius_deg * 2f;
        builder.dotSizeMeters = spec.dotSize_deg * spec.GetMetersPerDegree();
        builder.dotsPerField = spec.dotsPerField;
        builder.randomSeed = _currentTrial.seedA0;

        builder.BuildFromCondition(_currentCond);
        builder.SetDotsActive(false);

        if (targetResponseController != null)
        {
            targetResponseController.StopAndHide();
            targetResponseController.maxResponseFrames = maxResponseFrames;
        }

        if (csvLogger != null)
            csvLogger.BeginTrial(_currentTrial, spec, _currentCond);
    }

    void Update()
    {
        if (_currentCond == null || _phase == TrialPhase.Done)
            return;

        if (_phase == TrialPhase.WaitingForStart)
        {
            if (Input.GetKeyDown(startKey))
            {
                _phase = TrialPhase.Stimulus;
                builder.SetDotsActive(true);
            }

            if (hud != null) hud.Tick();
            return;
        }

        _accum += Time.deltaTime;
        while (_accum >= _simDt)
        {
            _accum -= _simDt;
            SimStep();
        }

        if (hud != null) hud.Tick();
    }

    private void SimStep()
    {
        if (_phase == TrialPhase.Stimulus) SimStepStimulus();
        else if (_phase == TrialPhase.TargetsResponse) SimStepTargetsResponse();
    }

    private void SimStepStimulus()
    {
        int N = _currentTrial.totalFrames;
        if (_frameInStimulus < 0 || _frameInStimulus >= N)
        {
            EnterTargetsPhase();
            return;
        }

        // Log the fixed columns ONCE per trial (frame 0)
        if (_frameInStimulus == 0 && csvLogger != null)
        {
            csvLogger.LogTrialRow(
                _currentTrial.index,
                _currentTrial.conditionID,
                _currentTrial.headingDeg,
                _currentTrial.onsetFrame,
                _currentTrial.translationStartFrame,
                _currentTrial.translationEndFrame,
                _currentTrial.totalFrames,
                _currentTrial.seedA0,
                _currentTrial.seedA1,
                _currentTrial.seedB2,
                _currentTrial.seedB3,
                spec.translationSpeed_degPerSec,
                spec.viewDistance_m
            );
        }

        builder.ApplyAppearance(_currentCond, _frameInStimulus);

        float dt = _simDt;
        float metersPerDeg = spec.GetMetersPerDegree();

        for (int i = 0; i < builder.Subfields.Length; i++)
        {
            var mk = _currentCond.subfields[i].motionKindByFrame[_frameInStimulus];

            switch (mk)
            {
                case CondLib.MotionKind.RotationCW:
                    builder.StepRotation(i, spec.rotationSpeed_degPerSec, dt, -1);
                    break;

                case CondLib.MotionKind.RotationCCW:
                    builder.StepRotation(i, spec.rotationSpeed_degPerSec, dt, +1);
                    break;

                case CondLib.MotionKind.Linear:
                {
                    float th = _currentTrial.headingDeg * Mathf.Deg2Rad;
                    float speed_mps = spec.translationSpeed_degPerSec * metersPerDeg;
                    Vector2 d = new Vector2(Mathf.Cos(th), Mathf.Sin(th)) * (speed_mps * dt);
                    builder.StepTranslation(i, d, _frameInStimulus);
                    break;
                }

                case CondLib.MotionKind.NonCoherent:
                    builder.StepNonCoherentBalanced(i, spec.translationSpeed_degPerSec, dt, metersPerDeg, _frameInStimulus);
                    break;

                default:
                    break;
            }
        }

        // Accumulate mkrows + colorrows into single TSV fields
        if (_currentCond.subfields != null)
        {
            int subCount = _currentCond.subfields.Length;
            int[] mkCodes = new int[subCount];
            string[] colorCodes = new string[subCount];

            for (int i = 0; i < subCount; i++)
            {
                var sf = _currentCond.subfields[i];

                mkCodes[i] = (sf.motionKindByFrame != null && _frameInStimulus < sf.motionKindByFrame.Length)
                    ? (int)sf.motionKindByFrame[_frameInStimulus]
                    : 0;

                if (sf.colorByFrame != null && _frameInStimulus < sf.colorByFrame.Length)
                    colorCodes[i] = EncodeColorLetter(sf.colorByFrame[_frameInStimulus]);
                else
                    colorCodes[i] = "K";
            }

            if (_mkPayloadBuilder.Length > 0) _mkPayloadBuilder.Append(";");
            _mkPayloadBuilder.Append(string.Join("|", mkCodes));

            if (_colorPayloadBuilder.Length > 0) _colorPayloadBuilder.Append(";");
            _colorPayloadBuilder.Append(string.Join("|", colorCodes));
        }

        _frameInStimulus++;

        if (_frameInStimulus >= _currentTrial.totalFrames)
            EnterTargetsPhase();
    }

    private void EnterTargetsPhase()
    {
        builder.SetDotsActive(false);
        _phase = TrialPhase.TargetsResponse;
        _responseFrameIndex = 0;

        if (targetResponseController != null)
            targetResponseController.BeginResponseWindow(0);
        else
            FinalizeTrialAndAdvance_NoResponse();
    }

    private void SimStepTargetsResponse()
    {
        if (targetResponseController == null)
        {
            FinalizeTrialAndAdvance_NoResponse();
            return;
        }

        bool finished = targetResponseController.TryStep(_responseFrameIndex, out TargetResponse resp);
        _responseFrameIndex++;

        if (!finished)
            return;

        bool requeue = (resp.status == ResponseStatus.Canceled || resp.status == ResponseStatus.TimedOut);
        if (resp.status == ResponseStatus.Confirmed) requeue = false;

        FinalizeTrialAndAdvance_WithResponse(resp, requeue);
    }

    private void FinalizeTrialAndAdvance_NoResponse()
    {
        if (csvLogger != null)
        {
            if (_mkPayloadBuilder.Length > 0)
                csvLogger.LogMkRows(_currentTrial.index, _mkPayloadBuilder.ToString());

            if (_colorPayloadBuilder.Length > 0)
                csvLogger.LogColorRows(_currentTrial.index, _colorPayloadBuilder.ToString());

            csvLogger.LogResponse(-1, -1, "", -1, "", "Keyboard");
            csvLogger.EndTrial();
        }

        _phase = TrialPhase.Done;
        NextTrial();
    }

    private void FinalizeTrialAndAdvance_WithResponse(TargetResponse resp, bool requeue)
    {
        if (csvLogger != null)
        {
            if (_mkPayloadBuilder.Length > 0)
                csvLogger.LogMkRows(_currentTrial.index, _mkPayloadBuilder.ToString());

            if (_colorPayloadBuilder.Length > 0)
                csvLogger.LogColorRows(_currentTrial.index, _colorPayloadBuilder.ToString());

            int responseIndex = (resp.status == ResponseStatus.Confirmed) ? resp.choiceIndex : -1;
            int rtFrames = resp.rtFrames;
            string endKey = (resp.key == KeyCode.None) ? "" : resp.key.ToString();
            string device = string.IsNullOrEmpty(resp.deviceLabel) ? "Keyboard" : resp.deviceLabel;

            MapChoiceToDigitAndDir(responseIndex, out int responseDigit, out string responseDir);

            csvLogger.LogResponse(responseIndex, responseDigit, responseDir, rtFrames, endKey, device);
            csvLogger.EndTrial();
        }

        if (requeue)
        {
            csvLogger?.AddRequeuedTrial(); // <-- keep meta honest
            if (_trialQueue == null) _trialQueue = new Queue<ExperimentSpec.PlannedTrial>();
            _trialQueue.Enqueue(_currentTrial);
        }

        _phase = TrialPhase.Done;
        NextTrial();
    }

    private static void MapChoiceToDigitAndDir(int responseIndex, out int digit, out string dir)
    {
        switch (responseIndex)
        {
            case 0: digit = 8; dir = "N";  break;
            case 1: digit = 9; dir = "NE"; break;
            case 2: digit = 6; dir = "E";  break;
            case 3: digit = 3; dir = "SE"; break;
            case 4: digit = 2; dir = "S";  break;
            case 5: digit = 1; dir = "SW"; break;
            case 6: digit = 4; dir = "W";  break;
            case 7: digit = 7; dir = "NW"; break;
            default: digit = -1; dir = "";  break;
        }
    }

    private static string EncodeColorLetter(Color c)
    {
        if (c.a < 0.5f || (c.r < 0.05f && c.g < 0.05f && c.b < 0.05f))
            return "K";

        if (c.r >= c.g && c.r >= c.b) return "R";
        if (c.g >= c.r && c.g >= c.b) return "G";
        if (c.b >= c.r && c.b >= c.g) return "B";
        return "Y";
    }

    // HUD read-only accessors
    public int TrialIndex => _startedTrialCount;
    public int TrialsCount => (_allPlannedTrials != null) ? _allPlannedTrials.Count : 0;
    public int FrameInTrial => _frameInStimulus;
    public float SimHz => (spec != null) ? spec.simHz : 0f;
    public ExperimentSpec.PlannedTrial CurrentTrial => _currentTrial;
}